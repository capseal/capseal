
Hereâ€™s how to tighten itâ€”and how to add your â€œterminal â‡„ AIâ€ split without turning the product back into a messy dashboard.

## 1) Fix â€œContinue Projectâ€ so it never dead-ends

Right now â€œContinueâ€ drops you into `/p/:id/runs` (or equivalent) and the Runs list is empty, so the UI says â€œselect a runâ€ with nothing to select. Thatâ€™s a UX contract violation: every screen needs a primary action.

Make â€œContinue Projectâ€ route to a *Project Overview* (even if minimal), not directly to Runs.

Project Overview should always have 3 actions, regardless of whether runs exist:

1. **New Run** (primary)
2. **Open Last Run** (only enabled if exists)
3. **Quick Trace** (secondary, runs the isolated flow inside this project context)

And it should show lightweight â€œstate tilesâ€:

* Last run: none / timestamp
* Verify status: unknown / last verified ok / last failed
* Engine: Local / Cloud (and â€œnot runningâ€ state)

If you donâ€™t want to add a whole new page, you can fake it by changing the empty state of Runs:

When runs list is empty, replace the â€œSelect a runâ€ empty state with:

* Primary button: **Create first run**
* Secondary: **Quick Trace**
* Tertiary: **Import capsule (.cap)** (optional but *very* on-brand)

That alone makes â€œContinueâ€ feel purposeful.

## 2) Add â€œpre-select optionsâ€ without adding complexity

Youâ€™re describing a â€œmode selectionâ€ step that should happen *before* you enter a project shell. Do it as a small overlay panel that appears when you click Continue:

**Continue Project â†’ Modal / Sheet**

* Choose project (list)
* Then choose â€œnext actionâ€ (radio buttons or 3 cards):

  * **Open Overview**
  * **Start New Run**
  * **Open Last Run** (disabled if none)

Default selection:

* If project has a last run â†’ default â€œOpen Last Runâ€
* Else â†’ default â€œStart New Runâ€

This makes the app feel â€œsmartâ€ without adding AI yet.

## 3) Your â€œterminal spaceâ€ idea: do it as a Dock, not a permanent panel

If you permanently reserve screen space, youâ€™ll hate it later (itâ€™ll make every page feel like an IDE clone). The Steve Jobs-coded move is: **everything is hidden until invoked, but instantly available**.

So: add a **bottom dock** that slides up.

Keybinds (simple, memorable):

* **Ctrl/âŒ˜ + J** â†’ toggle Terminal Dock
* **Ctrl/âŒ˜ + K** â†’ Command Palette (later)
* **Ctrl/âŒ˜ + L** â†’ toggle â€œAI Dockâ€ (or combine terminal+AI into one dock with tabs)

The dock itself should be one component used everywhere:
`DockPanel`

* Tabs: `Terminal` | `AI` | `Events` (Events is insanely on-brand for Capseal)
* Height: 35â€“45% of viewport when open
* Remembers last tab
* Can be popped out later, but donâ€™t start there

This gives you the â€œalternate between CLI work and AIâ€ rhythm without contaminating the rest of the UI.

## 4) What goes in â€œAIâ€ inside the dock?

Do **not** make it a general chatbot. Make it a *bounded copilot tied to the current screen context*.

Minimum viable AI dock:

* Title: â€œAssistantâ€
* Context line: `Project: X Â· Circuit: Y Â· Run: Z`
* 3 preset actions (buttons):

  1. **Explain this screen**
  2. **Generate command for what Iâ€™m doing**
  3. **Diagnose why this run failed**
* Then a text box.

Thatâ€™s it. The AI becomes a tool, not a new product.

## 5) The cleanest â€œcommand line â†” UIâ€ integration

You want the UI to feel like a shell around capseal, not a separate world. So unify them:

* Every major UI action should show the exact CLI command it corresponds to (copy button).
* Terminal dock should default to running in the selected projectâ€™s working directory.
* When the user runs a command in terminal, it can emit events into the Events tab (even if initially just â€œcaptured stdoutâ€).

This makes everything feel *tight* because itâ€™s one mental model.

## 6) Your specific screenshots: why it feels loose

Two main causes:

1. **Empty states are passive** (â€œSelect a runâ€) instead of action-oriented (â€œCreate first runâ€).
2. **You have too many â€œshellsâ€ that donâ€™t enforce a next step.** The product needs â€œrails,â€ not a rail.

The Launchpad screen you showed is actually closer to what you want. Itâ€™s just missing the follow-through contracts once you leave it.

## 7) Concrete implementation order (so it doesnâ€™t sprawl)

1. Change Runs empty state to action-driven (Create first run / Quick Trace / Import cap).
2. Add Continue modal with â€œnext actionâ€ selection.
3. Add DockPanel with Ctrl/âŒ˜+J toggle.
4. Terminal tab first (even if itâ€™s just a styled output box calling your backend).
5. AI tab later, but with the constrained presets above.

Once those exist, the whole app will start feeling like an instrument panel instead of a dark-themed dashboard.

If you keep the dock hidden until invoked, and make every empty state have a primary action, youâ€™ll get that â€œclosed, inevitable, Jobs-likeâ€ feel without needing to redesign everything again.
